---
phase: 03-outer-loop-core
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - bin/ralph.sh
  - bin/lib/parse.sh
autonomous: true

must_haves:
  truths:
    - "ralph.sh sources all lib files and initializes variables"
    - "parse_next_task extracts plan ID from STATE.md Next Action section"
    - "Main loop checks limits before each iteration"
    - "Loop exits cleanly when no next task found"
  artifacts:
    - path: "bin/ralph.sh"
      provides: "Main entry point for outer loop"
      min_lines: 80
    - path: "bin/lib/parse.sh"
      provides: "STATE.md parsing functions"
      min_lines: 40
  key_links:
    - from: "bin/ralph.sh"
      to: "bin/lib/budget.sh"
      via: "source statement"
      pattern: "source.*budget\\.sh"
    - from: "bin/ralph.sh"
      to: "bin/lib/parse.sh"
      via: "source statement"
      pattern: "source.*parse\\.sh"
    - from: "bin/ralph.sh"
      to: "bin/lib/state.sh"
      via: "source statement"
      pattern: "source.*state\\.sh"
---

<objective>
Create the ralph.sh script skeleton with main loop structure and STATE.md parsing.

Purpose: Establish the outer loop framework that will orchestrate autonomous plan execution. This is the core machinery that reads what to do next and iterates until done.

Output: Executable ralph.sh that loops, checks limits, parses next task, and exits when complete (but does not yet invoke Claude - that comes in Plan 02).
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-outer-loop-core/03-CONTEXT.md
@.planning/phases/03-outer-loop-core/03-RESEARCH.md
@bin/lib/budget.sh
@bin/lib/state.sh
@bin/lib/display.sh
@bin/lib/failfast.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create parse.sh with STATE.md parsing functions</name>
  <files>bin/lib/parse.sh</files>
  <action>
Create `bin/lib/parse.sh` with these functions:

1. `parse_next_task()` - Extract plan ID from STATE.md Next Action section
   - Read STATE.md (use STATE_FILE variable, default .planning/STATE.md)
   - Look for "Description: Execute plan XX-YY" pattern
   - Extract plan ID (e.g., "03-01") using grep
   - Return "COMPLETE" if no next action found
   - Return "ERROR" with exit code 1 if STATE.md missing

2. `get_current_phase()` - Extract current phase from STATE.md
   - Parse "Phase: X of Y (Name)" line
   - Return just the phase number

3. `get_plan_file_path()` - Resolve plan ID to file path
   - Args: plan_id (e.g., "03-01")
   - Find phase directory matching phase number
   - Return full path like ".planning/phases/03-outer-loop-core/03-01-PLAN.md"
   - Return empty string if not found

Follow existing lib file patterns:
- Use STATE_FILE variable with default
- Use same color code pattern (PARSE_RED, etc.)
- Include header comment with function list
- Return exit codes for caller handling (don't exit directly)

Reference the research patterns in 03-RESEARCH.md for implementation.
  </action>
  <verify>
Run: `bash -n bin/lib/parse.sh` (syntax check passes)
Run: Source the file and call `parse_next_task` - should return "03-01" given current STATE.md
  </verify>
  <done>
parse.sh exists with parse_next_task, get_current_phase, and get_plan_file_path functions. All return expected values when sourced and called.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create ralph.sh main script skeleton</name>
  <files>bin/ralph.sh</files>
  <action>
Create `bin/ralph.sh` with this structure:

1. **Shebang and strict mode:**
   ```bash
   #!/bin/bash
   set -euo pipefail
   ```

2. **Script directory detection:**
   ```bash
   SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
   ```

3. **Source all lib files:**
   - budget.sh, state.sh, display.sh, failfast.sh, parse.sh
   - Use SCRIPT_DIR for relative paths

4. **Command-line argument parsing:**
   - `--start-from PLAN_ID` to override starting point
   - Store in START_FROM_OVERRIDE variable (empty by default)

5. **Configuration loading and startup display:**
   - Call load_config from budget.sh
   - Show startup summary: config values, current position, next task
   - Use show_status from display.sh for colored output

6. **Initialize timing:**
   - Set START_TIME=$(date +%s) before loop

7. **Main loop skeleton:**
   ```bash
   iteration=0
   while true; do
       iteration=$((iteration + 1))

       # Check limits (from failfast.sh)
       if ! check_limits "$iteration"; then
           handle_limit_reached
           exit 1
       fi

       # Parse next task
       next_task=$(parse_next_task)

       # Handle override on first iteration
       if [[ $iteration -eq 1 && -n "$START_FROM_OVERRIDE" ]]; then
           next_task="$START_FROM_OVERRIDE"
       fi

       # Check for completion
       if [[ -z "$next_task" || "$next_task" == "COMPLETE" ]]; then
           show_status "All tasks complete!" "success"
           break
       fi

       # TODO: Invoke Claude (Plan 02)
       echo "Would execute: $next_task"

       # For now, just exit after showing what would run
       break
   done
   ```

8. **Exit message:**
   - Show final status and elapsed time

Make executable with `chmod +x bin/ralph.sh`.

Follow patterns from 03-RESEARCH.md startup summary example.
  </action>
  <verify>
Run: `bash -n bin/ralph.sh` (syntax check passes)
Run: `./bin/ralph.sh` from project root - should show startup summary and "Would execute: 03-01"
  </verify>
  <done>
ralph.sh exists, is executable, sources all libs, parses args, shows startup summary, and runs one loop iteration displaying what task would execute.
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire state updates into loop</name>
  <files>bin/ralph.sh</files>
  <action>
Extend ralph.sh to update STATE.md during the loop:

1. **Before loop starts:**
   - Call mark_checkpoint from failfast.sh to record git HEAD
   - Display checkpoint confirmation

2. **Add iteration logging:**
   - Create log_iteration function or use inline logging
   - Append to .planning/ralph.log with format from 03-RESEARCH.md:
     ```
     ---
     Iteration: N
     Timestamp: YYYY-MM-DD HH:MM:SS
     Task: XX-YY
     Status: PENDING (before execution)
     ```

3. **Progress display before "Would execute":**
   - Call show_progress from display.sh with iteration, max, task

4. **Add 30-minute alert check (placeholder):**
   - Record iteration_start_time=$(date +%s) before execution
   - After execution (currently the TODO), check if elapsed > 1800 seconds
   - If exceeded, log warning to ralph.log and display yellow alert

This task adds the state/logging plumbing. Actual Claude invocation comes in Plan 02.

Do NOT remove the "break" statement yet - the loop should still exit after one iteration until Plan 02 adds real execution.
  </action>
  <verify>
Run: `./bin/ralph.sh` - should show checkpoint, progress display, log entry created
Run: `cat .planning/ralph.log` - should contain iteration entry
  </verify>
  <done>
ralph.sh creates checkpoint, displays progress, logs iterations to ralph.log, has 30-minute alert placeholder. Loop still exits after showing what would execute.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `bash -n bin/ralph.sh` passes (no syntax errors)
2. `bash -n bin/lib/parse.sh` passes
3. Running `./bin/ralph.sh` shows:
   - Startup config summary
   - Checkpoint marker
   - Progress display
   - "Would execute: 03-01"
4. `.planning/ralph.log` contains iteration entry
5. All lib files properly sourced (no "command not found" errors)
</verification>

<success_criteria>
- ralph.sh exists at bin/ralph.sh and is executable
- parse.sh exists at bin/lib/parse.sh
- ralph.sh sources all 5 lib files without errors
- parse_next_task returns correct plan ID from STATE.md
- Main loop structure is in place with limit checking
- --start-from argument parsing works
- State and logging wiring is complete
- Ready for Plan 02 to add Claude invocation
</success_criteria>

<output>
After completion, create `.planning/phases/03-outer-loop-core/03-01-SUMMARY.md`
</output>
