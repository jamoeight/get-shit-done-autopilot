---
phase: 12-failure-learnings
plan: 02
type: execute
wave: 2
depends_on: ["12-01"]
files_modified:
  - bin/lib/learnings.sh
  - bin/ralph.sh
autonomous: true

must_haves:
  truths:
    - "When a task fails, failure context is automatically extracted and stored"
    - "Retry attempts receive previous failure learnings in their prompt"
    - "When phase completes successfully, failure learnings for that phase are cleared"
    - "User can review failure learnings by reading AGENTS.md"
  artifacts:
    - path: "bin/ralph.sh"
      provides: "Failure extraction on task failure, cleanup on phase completion"
      contains: "extract_and_store_failure"
    - path: "bin/lib/learnings.sh"
      provides: "Extended get_learnings_for_phase with failure context"
      exports: ["get_learnings_for_phase"]
  key_links:
    - from: "handle_iteration_failure_state"
      to: "extract_and_store_failure"
      via: "function call after logging failure"
      pattern: "extract_and_store_failure.*task.*output_file"
    - from: "handle_iteration_success"
      to: "clear_phase_failures"
      via: "phase boundary detection"
      pattern: "clear_phase_failures.*phase_num"
    - from: "get_learnings_for_phase"
      to: "Failure Context section"
      via: "sed extraction"
      pattern: "Failure Context"
---

<objective>
Integrate failure learnings into ralph.sh execution loop

Purpose: Wire the failure extraction and storage functions from 12-01 into the execution loop so failures are automatically captured, stored, included in retry prompts, and cleaned up on phase completion. This completes the failure learnings feature.

Output: Modified ralph.sh with failure extraction on failure, cleanup on phase boundary; extended get_learnings_for_phase that includes failure context in prompts.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-failure-learnings/12-CONTEXT.md
@.planning/phases/12-failure-learnings/12-RESEARCH.md
@.planning/phases/12-failure-learnings/12-01-SUMMARY.md
@bin/lib/learnings.sh
@bin/ralph.sh
@bin/lib/invoke.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend get_learnings_for_phase to include failure context</name>
  <files>bin/lib/learnings.sh</files>
  <action>
Modify the existing get_learnings_for_phase function to include failure context:

After the existing phase_specific extraction (around line 122), add extraction for failure context:

```bash
# Extract failure context for this phase from ## Failure Context section
local failure_context
if [[ -n "$phase_num" ]]; then
    # First find the Failure Context section, then extract the phase subsection
    failure_context=$(awk -v phase="$phase_num" '
        /^## Failure Context/ { in_failure = 1; next }
        /^## / && in_failure { in_failure = 0 }
        in_failure && $0 ~ "^### Phase " phase ":" { in_phase = 1; next }
        in_failure && /^### Phase/ && in_phase { in_phase = 0 }
        in_failure && in_phase { print }
    ' "$AGENTS_FILE")
fi
```

Then, add failure context to the output after the phase-specific section (around line 153):

```bash
# Add failure context if any (helps retries avoid repeated mistakes)
if [[ -n "$failure_context" && -n "$(echo "$failure_context" | tr -d '[:space:]')" ]]; then
    if [[ -n "$output" ]]; then
        output+=$'\n'
    fi
    output+="Failure Context (avoid repeating these mistakes):"
    output+=$'\n'
    output+="$failure_context"
fi
```

This ensures retry attempts automatically receive previous failure information without any changes to invoke.sh (it already calls get_learnings_for_phase).
  </action>
  <verify>
Run these test commands:
```bash
source bin/lib/learnings.sh

# Add a test failure
append_failure_learning "12-01" "Test error for prompt" "Ran tests" "test.sh" "Missing config"

# Get learnings and verify failure context included
learnings=$(get_learnings_for_phase 12)
echo "$learnings" | grep -q "Failure Context" && echo "PASS: Failure context section present"
echo "$learnings" | grep -q "Test error for prompt" && echo "PASS: Failure details included"
echo "$learnings" | grep -q "avoid repeating" && echo "PASS: Header indicates purpose"

# Clean up test failure
clear_phase_failures 12
```
  </verify>
  <done>get_learnings_for_phase returns failure context for the requested phase, enabling retry prompts to include previous failure information</done>
</task>

<task type="auto">
  <name>Task 2: Add failure extraction to ralph.sh on task failure</name>
  <files>bin/ralph.sh</files>
  <action>
Modify ralph.sh to extract and store failures when tasks fail:

**1. Add extract_and_store_failure helper function** (after handle_iteration_failure_state, around line 125):

```bash
# extract_and_store_failure - Extract failure details and store as learning
# Args: task_id, output_file, error_msg
# Called when a task fails to capture context for retries
extract_and_store_failure() {
    local task_id="$1"
    local output_file="$2"
    local error_msg="$3"

    # Skip if learnings functions not available
    if ! type extract_failure_reason &>/dev/null; then
        return 0
    fi

    # Extract detailed failure reason from Claude's output
    local failure_reason=""
    if [[ -n "$output_file" && -f "$output_file" ]]; then
        failure_reason=$(extract_failure_reason "$output_file")
    fi

    # Build "attempted" from task context
    local attempted="Executed task ${task_id}"

    # Extract file paths mentioned in output (best effort)
    local files=""
    if [[ -n "$output_file" && -f "$output_file" ]]; then
        # Look for file paths in the output (common patterns)
        files=$(grep -oE '[a-zA-Z0-9_/-]+\.(sh|ts|js|md|json)' "$output_file" 2>/dev/null | sort -u | head -5 | tr '\n' ', ' | sed 's/,$//')
    fi
    files="${files:-unknown}"

    # Use failure_reason as context if different from error_msg
    local context="$error_msg"
    if [[ -n "$failure_reason" && "$failure_reason" != "$error_msg" ]]; then
        context="$failure_reason"
    fi

    # Store the failure learning
    append_failure_learning "$task_id" "$error_msg" "$attempted" "$files" "$context"
}
```

**2. Modify handle_iteration_failure_state** to accept output_file and call extraction:

Change the function signature and add extraction call (around line 111):

```bash
# handle_iteration_failure_state - Process failed iteration (state only)
# Args: iteration, task, error, duration, output_file (optional)
# Updates STATE.md but does NOT advance next_action (retry same task)
handle_iteration_failure_state() {
    local iteration_num="$1"
    local task="$2"
    local error="$3"
    local duration="$4"
    local output_file="${5:-}"

    # Log the iteration
    log_iteration "$iteration_num" "FAILURE" "$task" "$error" "$duration"

    # Add entry to STATE.md history
    add_iteration_entry "$iteration_num" "FAILURE" "$task: $error"

    # Extract and store failure learning for retry context
    if [[ -n "$output_file" ]]; then
        extract_and_store_failure "$task" "$output_file" "$error"
    fi

    # Do NOT update next_action - stay on same task for retry
}
```

**3. Update the failure handling call** in the main loop (around line 357):

Change from:
```bash
handle_iteration_failure_state "$iteration" "$next_task" "$error_msg" "$iteration_duration"
```

To:
```bash
handle_iteration_failure_state "$iteration" "$next_task" "$error_msg" "$iteration_duration" "$output_file"
```

Note: The output_file cleanup (rm -f "$output_file") on line 354 needs to move AFTER the failure state handling. Move it to after line 357.
  </action>
  <verify>
Run these commands to verify the changes:
```bash
# Check extract_and_store_failure function exists
grep -q "extract_and_store_failure" bin/ralph.sh && echo "PASS: Function added"

# Check handle_iteration_failure_state accepts output_file
grep -A5 "handle_iteration_failure_state()" bin/ralph.sh | grep -q 'output_file' && echo "PASS: Signature updated"

# Check the call passes output_file
grep "handle_iteration_failure_state.*output_file" bin/ralph.sh && echo "PASS: Call updated"

# Syntax check
bash -n bin/ralph.sh && echo "PASS: No syntax errors"
```
  </verify>
  <done>ralph.sh extracts and stores failure learnings when tasks fail, passing failure context to the learnings system</done>
</task>

<task type="auto">
  <name>Task 3: Add phase boundary cleanup to ralph.sh</name>
  <files>bin/ralph.sh</files>
  <action>
Modify handle_iteration_success to clear failure learnings when a phase completes:

**1. Add phase boundary detection and cleanup** in handle_iteration_success (after determining next_plan, around line 93):

After the line `next_plan=$(get_next_plan_after "$task")`, add:

```bash
    # Check for phase boundary - clear failure learnings when phase completes
    if type clear_phase_failures &>/dev/null; then
        local current_phase="${task%%-*}"
        current_phase=$((10#$current_phase))  # Remove leading zero

        if [[ "$next_plan" == "COMPLETE" ]]; then
            # All phases done - clear current phase failures
            clear_phase_failures "$current_phase"
        else
            local next_phase="${next_plan%%-*}"
            next_phase=$((10#$next_phase))

            if [[ "$next_phase" -gt "$current_phase" ]]; then
                # Phase boundary crossed - clear completed phase failures
                clear_phase_failures "$current_phase"
            fi
        fi
    fi
```

This ensures failure learnings are cleared when:
- A phase completes successfully and we move to the next phase
- All phases complete (next_plan == "COMPLETE")

Failures within a phase accumulate for retries, but once the phase succeeds, they're cleared for a fresh start.
  </action>
  <verify>
Run these commands to verify:
```bash
# Check phase boundary cleanup logic exists
grep -A10 "phase boundary" bin/ralph.sh | grep -q "clear_phase_failures" && echo "PASS: Phase cleanup added"

# Check it handles both COMPLETE and phase transitions
grep -B2 -A2 'next_plan.*COMPLETE' bin/ralph.sh | grep -q "clear_phase_failures" && echo "PASS: Handles completion"
grep -B2 -A2 'next_phase.*-gt.*current_phase' bin/ralph.sh | grep -q "clear_phase_failures" && echo "PASS: Handles phase boundary"

# Syntax check
bash -n bin/ralph.sh && echo "PASS: No syntax errors"
```
  </verify>
  <done>ralph.sh clears phase failure learnings when a phase completes successfully, providing a fresh start for the next phase</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Verify learnings flow end-to-end:
```bash
source bin/lib/learnings.sh

# Simulate a failure being stored
append_failure_learning "12-test" "Simulated test failure" "Ran task 12-test" "bin/ralph.sh" "Test context for verification"

# Verify it appears in learnings
learnings=$(get_learnings_for_phase 12)
echo "$learnings" | grep -q "Simulated test failure" && echo "E2E Storage: OK"
echo "$learnings" | grep -q "Failure Context" && echo "E2E Prompt section: OK"

# Verify cleanup works
clear_phase_failures 12
learnings=$(get_learnings_for_phase 12)
! echo "$learnings" | grep -q "Simulated test failure" && echo "E2E Cleanup: OK"
```

2. Verify ralph.sh integration points:
```bash
# All integration points present
grep -q "extract_and_store_failure" bin/ralph.sh && echo "Extraction function: OK"
grep -q "clear_phase_failures" bin/ralph.sh && echo "Cleanup integration: OK"
grep "handle_iteration_failure_state.*output_file" bin/ralph.sh && echo "Failure call updated: OK"

# No syntax errors
bash -n bin/ralph.sh && echo "Syntax check: OK"
```

3. Verify requirements met:
- FAIL-01: extract_failure_reason parses Claude output - "OK if Task 1 12-01 passed"
- FAIL-02: append_failure_learning creates structured entries - "OK if Task 2 12-01 passed"
- FAIL-03: Failures stored in AGENTS.md Failure Context - "OK if Task 2 12-01 passed"
- FAIL-04: get_learnings_for_phase includes failures - "OK if Task 1 passed"
</verification>

<success_criteria>
- get_learnings_for_phase includes failure context in its output
- ralph.sh extracts and stores failures when handle_iteration_failure_state is called
- ralph.sh clears phase failures on successful phase completion
- Retry prompts automatically include previous failure learnings (via existing invoke.sh flow)
- All 4 FAIL requirements are satisfied
- bash -n bin/ralph.sh passes (no syntax errors)
</success_criteria>

<output>
After completion, create `.planning/phases/12-failure-learnings/12-02-SUMMARY.md`
</output>
