#!/bin/bash
# GSD Ralph - Learnings Propagation
# Part of Phase 7: Learnings Propagation
#
# Provides AGENTS.md management functions for learning extraction, storage,
# and retrieval. Learnings are project-specific patterns discovered during
# autonomous execution that improve future iterations.
#
# Functions: init_agents_file, get_learnings_for_phase, append_learning,
#            extract_learnings_from_summary, prune_agents_if_needed
#
# Usage:
#   source bin/lib/learnings.sh
#   init_agents_file
#   append_learning "Error Fixes" "When permission denied on shell scripts, run chmod +x bin/*.sh"
#   get_learnings_for_phase 7

# Configuration
AGENTS_FILE="${AGENTS_FILE:-.planning/AGENTS.md}"
MAX_AGENTS_LINES=100
MAX_AGENTS_LINES_HARD=150

# Color codes (respect NO_COLOR standard)
if [[ -n "${NO_COLOR:-}" ]]; then
    LEARN_RED=''
    LEARN_YELLOW=''
    LEARN_RESET=''
else
    LEARN_RED='\e[31m'
    LEARN_YELLOW='\e[33m'
    LEARN_RESET='\e[0m'
fi

# =============================================================================
# Initialization Functions
# =============================================================================

# init_agents_file - Create AGENTS.md with initial structure
# Returns: 0 on success, 1 on failure
# Creates .planning directory if needed, uses atomic write pattern
init_agents_file() {
    # Ensure directory exists
    local agents_dir
    agents_dir=$(dirname "$AGENTS_FILE")
    if [[ ! -d "$agents_dir" ]]; then
        mkdir -p "$agents_dir"
    fi

    # Create initial structure
    local content
    content='# Project Learnings

Project-specific patterns discovered during autonomous execution.
Auto-generated by ralph.sh - manual edits preserved.

## Error Fixes

When you encounter specific errors, apply these fixes:

## Codebase Patterns

Project conventions discovered during execution:

## Phase-Specific

'
    # Write to temp then mv for atomicity
    local temp="${AGENTS_FILE}.tmp.$$"
    printf '%s' "$content" > "$temp"

    if [[ $? -ne 0 ]]; then
        echo -e "${LEARN_RED}Error: Failed to write temp file${LEARN_RESET}" >&2
        rm -f "$temp" 2>/dev/null
        return 1
    fi

    mv "$temp" "$AGENTS_FILE"
    return $?
}

# =============================================================================
# Section Loading Functions
# =============================================================================

# get_learnings_for_phase - Extract relevant sections from AGENTS.md
# Args: phase_num - The phase number to load learnings for
# Output: Concatenated relevant learnings to stdout
# Returns: 0 always (missing file is OK - no learnings yet)
#
# Loads: "Error Fixes" (always), "Codebase Patterns" (always),
#        "Phase {N}" subsection under Phase-Specific if exists
get_learnings_for_phase() {
    local phase_num="$1"

    if [[ ! -f "$AGENTS_FILE" ]]; then
        return 0  # No learnings yet, OK
    fi

    # Extract "Error Fixes" section content (between ## Error Fixes and next ##)
    local error_fixes
    error_fixes=$(sed -n '/^## Error Fixes/,/^## /{
        /^## Error Fixes/d
        /^## /d
        p
    }' "$AGENTS_FILE")

    # Extract "Codebase Patterns" section content
    local codebase_patterns
    codebase_patterns=$(sed -n '/^## Codebase Patterns/,/^## /{
        /^## Codebase Patterns/d
        /^## /d
        p
    }' "$AGENTS_FILE")

    # Extract phase-specific subsection (### Phase N:)
    local phase_specific
    if [[ -n "$phase_num" ]]; then
        phase_specific=$(sed -n "/^### Phase ${phase_num}:/,/^### /{
            /^### Phase ${phase_num}:/d
            /^### /d
            p
        }" "$AGENTS_FILE")
    fi

    # Extract failure context for this phase from ## Failure Context section
    local failure_context
    if [[ -n "$phase_num" ]]; then
        # First find the Failure Context section, then extract the phase subsection
        failure_context=$(awk -v phase="$phase_num" '
            /^## Failure Context/ { in_failure = 1; next }
            /^## / && in_failure { in_failure = 0 }
            in_failure && $0 ~ "^### Phase " phase ":" { in_phase = 1; next }
            in_failure && /^### Phase/ && in_phase { in_phase = 0 }
            in_failure && in_phase { print }
        ' "$AGENTS_FILE")
    fi

    # Output combined learnings
    local output=""

    # Add error fixes if any
    if [[ -n "$error_fixes" && -n "$(echo "$error_fixes" | tr -d '[:space:]')" ]]; then
        output+="Error Fixes:"
        output+=$'\n'
        output+="$error_fixes"
    fi

    # Add codebase patterns if any
    if [[ -n "$codebase_patterns" && -n "$(echo "$codebase_patterns" | tr -d '[:space:]')" ]]; then
        if [[ -n "$output" ]]; then
            output+=$'\n'
        fi
        output+="Codebase Patterns:"
        output+=$'\n'
        output+="$codebase_patterns"
    fi

    # Add phase-specific if any
    if [[ -n "$phase_specific" && -n "$(echo "$phase_specific" | tr -d '[:space:]')" ]]; then
        if [[ -n "$output" ]]; then
            output+=$'\n'
        fi
        output+="Phase ${phase_num} specific:"
        output+=$'\n'
        output+="$phase_specific"
    fi

    # Add failure context if any (helps retries avoid repeated mistakes)
    if [[ -n "$failure_context" && -n "$(echo "$failure_context" | tr -d '[:space:]')" ]]; then
        if [[ -n "$output" ]]; then
            output+=$'\n'
        fi
        output+="Failure Context (avoid repeating these mistakes):"
        output+=$'\n'
        output+="$failure_context"
    fi

    echo "$output"
    return 0
}

# =============================================================================
# Learning Storage Functions
# =============================================================================

# append_learning - Add learning if not already present
# Args: section - Target section name (e.g., "Error Fixes", "Codebase Patterns", "Phase 5")
#       learning - The learning text to add (will be prefixed with "- ")
# Returns: 0 on success (including if already exists - idempotent)
#
# Deduplication: Uses grep -qF for exact match check
# For "Phase N" sections, creates as ### subsection under ## Phase-Specific
append_learning() {
    local section="$1"
    local learning="$2"

    if [[ -z "$section" || -z "$learning" ]]; then
        echo -e "${LEARN_RED}Error: append_learning requires section and learning${LEARN_RESET}" >&2
        return 1
    fi

    # Ensure AGENTS.md exists
    if [[ ! -f "$AGENTS_FILE" ]]; then
        init_agents_file
    fi

    # Check if learning already exists (exact match deduplication)
    if grep -qF "$learning" "$AGENTS_FILE" 2>/dev/null; then
        return 0  # Already exists, silently skip (idempotent)
    fi

    # Determine if this is a phase-specific section (Phase N)
    local is_phase_section=false
    local phase_num=""
    if [[ "$section" =~ ^Phase\ ([0-9]+)$ ]]; then
        is_phase_section=true
        phase_num="${BASH_REMATCH[1]}"
    fi

    # Create temp file for atomic write
    local temp
    temp=$(mktemp)

    if [[ "$is_phase_section" == "true" ]]; then
        # Phase-specific: Add under ## Phase-Specific as ### Phase N: subsection
        local subsection_header="### Phase ${phase_num}:"

        # Check if subsection exists
        if grep -q "^${subsection_header}$" "$AGENTS_FILE" 2>/dev/null; then
            # Subsection exists - insert after header
            awk -v header="$subsection_header" -v learning="- $learning" '
                $0 == header {
                    print
                    getline
                    print
                    print learning
                    next
                }
                { print }
            ' "$AGENTS_FILE" > "$temp"
        else
            # Subsection doesn't exist - create it under Phase-Specific
            awk -v header="$subsection_header" -v learning="- $learning" '
                /^## Phase-Specific/ {
                    print
                    getline
                    print
                    print header
                    print ""
                    print learning
                    print ""
                    next
                }
                { print }
            ' "$AGENTS_FILE" > "$temp"
        fi
    else
        # Regular section (Error Fixes, Codebase Patterns)
        local section_header="## $section"

        # Check if section exists
        if grep -q "^${section_header}$" "$AGENTS_FILE" 2>/dev/null; then
            # Section exists - insert after intro text (header + intro line + blank)
            # Pattern: ## Header\n\nIntro text:\n\n<learnings go here>
            awk -v header="$section_header" -v learning="- $learning" '
                BEGIN { found_header = 0; blank_count = 0; added = 0 }
                $0 == header {
                    found_header = 1
                    print
                    next
                }
                found_header && !added {
                    if (/^$/) {
                        blank_count++
                        print
                        # After second blank line (after intro text), insert learning
                        if (blank_count == 2) {
                            print learning
                            added = 1
                            found_header = 0
                        }
                        next
                    }
                    # If we hit a list item before second blank, insert before it
                    if (/^- /) {
                        print learning
                        added = 1
                        found_header = 0
                    }
                    # Print the current line
                    print
                    next
                }
                { print }
            ' "$AGENTS_FILE" > "$temp"
        else
            # Section doesn't exist - create it at end of file
            cp "$AGENTS_FILE" "$temp"
            {
                echo ""
                echo "$section_header"
                echo ""
                echo "- $learning"
                echo ""
            } >> "$temp"
        fi
    fi

    # Atomic replace
    mv "$temp" "$AGENTS_FILE"
    return $?
}

# =============================================================================
# Learning Extraction Functions
# =============================================================================

# extract_learnings_from_summary - Parse SUMMARY.md frontmatter for learnings
# Args: summary_file - Path to SUMMARY.md
#       task_id - Task ID (e.g., "07-01") to determine phase number
# Returns: 0 always (missing file is OK - nothing to extract)
#
# Extracts patterns-established -> Phase N section
# Extracts key-decisions -> Codebase Patterns section
extract_learnings_from_summary() {
    local summary_file="$1"
    local task_id="$2"

    if [[ ! -f "$summary_file" ]]; then
        return 0  # No summary file, nothing to extract
    fi

    # Parse task_id to get phase number (e.g., "07-01" -> "7")
    local phase_num="${task_id%%-*}"
    # Remove leading zero (e.g., "07" -> "7")
    phase_num=$((10#$phase_num))

    # Extract only the YAML frontmatter (between --- markers)
    local frontmatter
    frontmatter=$(sed -n '/^---$/,/^---$/{
        /^---$/d
        p
    }' "$summary_file")

    # Extract patterns-established from frontmatter
    # Format: patterns-established:
    #   - "pattern1"
    #   - "pattern2"
    local patterns
    patterns=$(echo "$frontmatter" | sed -n '/^patterns-established:/,/^[a-z]/{
        /^patterns-established:/d
        /^[a-z]/d
        s/^[[:space:]]*- //
        s/"//g
        /^$/d
        p
    }')

    # Extract key-decisions from frontmatter
    local decisions
    decisions=$(echo "$frontmatter" | sed -n '/^key-decisions:/,/^[a-z]/{
        /^key-decisions:/d
        /^[a-z]/d
        s/^[[:space:]]*- //
        s/"//g
        /^$/d
        p
    }')

    # Store each pattern in phase-specific section
    while IFS= read -r pattern; do
        if [[ -n "$pattern" ]]; then
            append_learning "Phase ${phase_num}" "$pattern"
        fi
    done <<< "$patterns"

    # Store each decision in Codebase Patterns section
    while IFS= read -r decision; do
        if [[ -n "$decision" ]]; then
            append_learning "Codebase Patterns" "$decision"
        fi
    done <<< "$decisions"

    return 0
}

# =============================================================================
# Failure Learning Functions
# =============================================================================

# ensure_failure_section - Create Failure Context section if it doesn't exist
# Returns: 0 always
# Creates AGENTS.md via init_agents_file if needed
ensure_failure_section() {
    if [[ ! -f "$AGENTS_FILE" ]]; then
        init_agents_file
    fi

    # Check if Failure Context section exists
    if grep -q "^## Failure Context" "$AGENTS_FILE" 2>/dev/null; then
        return 0
    fi

    # Append Failure Context section at end
    {
        echo ""
        echo "## Failure Context"
        echo ""
        echo "Failure learnings from current phase - cleared on phase completion."
        echo ""
    } >> "$AGENTS_FILE"

    return 0
}

# extract_failure_reason - Extract failure information from Claude's JSON output
# Args: output_file - Path to Claude's JSON output file
# Output: Extracted failure reason to stdout
# Returns: 0 always (extraction is best-effort)
#
# Tries multiple extraction strategies:
# 1. Look for FAILURE_REASON: marker in .result field
# 2. Extract .error field from JSON
# 3. Grep for common error patterns
# 4. Default fallback message
extract_failure_reason() {
    local output_file="$1"

    if [[ -z "$output_file" || ! -f "$output_file" ]]; then
        echo "Task failed (no specific error message captured)"
        return 0
    fi

    # Primary extraction: Look for structured markers in Claude's result
    local result=""
    if command -v jq &>/dev/null; then
        result=$(jq -r '.result // empty' "$output_file" 2>/dev/null)
    else
        # Fallback: Extract result field using grep/sed
        result=$(grep -o '"result"[[:space:]]*:[[:space:]]*"[^"]*"' "$output_file" 2>/dev/null | sed 's/"result"[[:space:]]*:[[:space:]]*"//' | sed 's/"$//')
    fi

    # Try to find FAILURE_REASON marker in the extracted result text
    if [[ -n "$result" ]]; then
        # Use grep with Perl regex for better pattern matching
        local reason
        if echo "$result" | grep -q 'FAILURE_REASON:'; then
            reason=$(echo "$result" | grep -oP 'FAILURE_REASON:\s*\K.*' 2>/dev/null | head -1)
            # If Perl regex not available, fall back to sed
            if [[ -z "$reason" ]]; then
                reason=$(echo "$result" | grep 'FAILURE_REASON:' | sed 's/.*FAILURE_REASON:[[:space:]]*//' | head -1)
            fi
            if [[ -n "$reason" ]]; then
                # Truncate at 500 chars, preserving complete words
                if [[ ${#reason} -gt 500 ]]; then
                    reason=$(echo "$reason" | cut -c1-500 | sed 's/[[:space:]][^[:space:]]*$//')
                fi
                echo "$reason"
                return 0
            fi
        fi
    fi

    # Fallback: Extract error field from JSON
    local error=""
    if command -v jq &>/dev/null; then
        error=$(jq -r '.error // empty' "$output_file" 2>/dev/null)
    else
        # Fallback: Extract error field using grep/sed
        error=$(grep -o '"error"[[:space:]]*:[[:space:]]*"[^"]*"' "$output_file" 2>/dev/null | sed 's/"error"[[:space:]]*:[[:space:]]*"//' | sed 's/"$//')
    fi

    if [[ -n "$error" && "$error" != "null" ]]; then
        # Truncate at 500 chars, preserving complete words
        if [[ ${#error} -gt 500 ]]; then
            error=$(echo "$error" | cut -c1-500 | sed 's/[[:space:]][^[:space:]]*$//')
        fi
        echo "$error"
        return 0
    fi

    # Fallback: Look for common error patterns in the result field first
    if [[ -n "$result" ]]; then
        local error_pattern
        error_pattern=$(echo "$result" | grep -iE '(error|failed|exception|cannot|not found)' | head -1)
        if [[ -n "$error_pattern" ]]; then
            # Truncate at 500 chars
            if [[ ${#error_pattern} -gt 500 ]]; then
                error_pattern=$(echo "$error_pattern" | cut -c1-500 | sed 's/[[:space:]][^[:space:]]*$//')
            fi
            echo "$error_pattern"
            return 0
        fi
    fi

    # Final fallback: Look for error patterns directly in the file
    local file_error
    file_error=$(grep -iE '(error|failed|exception|cannot|not found):?' "$output_file" 2>/dev/null | head -1 | cut -c1-500)
    if [[ -n "$file_error" ]]; then
        echo "$file_error"
        return 0
    fi

    echo "Task failed (no specific error message captured)"
    return 0
}

# append_failure_learning - Add failure learning to AGENTS.md
# Args: task_id - Task ID (e.g., "12-01")
#       error_msg - Error message
#       attempted - What was attempted (2-3 sentences)
#       files - Relevant file paths
#       context - Additional context
# Returns: 0 on success, 1 on invalid args
#
# Stores structured failure entry with timestamp under phase subsection
# Enforces 100-failure cap per phase before appending
append_failure_learning() {
    local task_id="$1"
    local error_msg="$2"
    local attempted="$3"
    local files="$4"
    local context="$5"

    if [[ -z "$task_id" || -z "$error_msg" ]]; then
        echo -e "${LEARN_RED}Error: append_failure_learning requires task_id and error_msg${LEARN_RESET}" >&2
        return 1
    fi

    # Extract phase number from task_id (e.g., "12-01" -> 12)
    local phase_num="${task_id%%-*}"
    phase_num=$((10#$phase_num))  # Remove leading zeros

    # Generate timestamp
    local timestamp
    timestamp=$(date '+%Y-%m-%d %H:%M:%S' 2>/dev/null || echo "unknown")

    # Escape special characters for awk/sed safety
    # Replace & with \&, backslash with \\, single quote with '\''
    error_msg=$(echo "$error_msg" | sed "s/&/\\\\&/g; s/'/'\\\\''/g")
    attempted=$(echo "$attempted" | sed "s/&/\\\\&/g; s/'/'\\\\''/g")
    context=$(echo "$context" | sed "s/&/\\\\&/g; s/'/'\\\\''/g")

    # Format the failure entry (multi-line markdown)
    local entry="- [${task_id} | ${timestamp}] **Error:** ${error_msg}
  **Attempted:** ${attempted}
  **Files:** ${files}
  **Context:** ${context}"

    # Ensure AGENTS.md exists with Failure Context section
    ensure_failure_section

    # Check and enforce failure cap before appending
    enforce_failure_cap "$phase_num"

    # Create temp file for atomic write
    local temp
    temp=$(mktemp)

    local subsection_header="### Phase ${phase_num}:"

    # Check if subsection exists
    if grep -q "^${subsection_header}$" "$AGENTS_FILE" 2>/dev/null; then
        # Subsection exists - append to end of subsection
        awk -v header="$subsection_header" -v entry="$entry" '
            BEGIN { in_section = 0; added = 0 }
            $0 == header { in_section = 1; print; next }
            in_section && /^### / && !added {
                # Hit next subsection - insert before it
                print ""
                print entry
                print ""
                added = 1
                in_section = 0
                print
                next
            }
            in_section && /^## / && !added {
                # Hit next section - insert before it
                print ""
                print entry
                print ""
                added = 1
                in_section = 0
                print
                next
            }
            { print }
            END {
                # If we reached EOF while in section, append at end
                if (in_section && !added) {
                    print ""
                    print entry
                }
            }
        ' "$AGENTS_FILE" > "$temp"
    else
        # Subsection doesn't exist - create it under Failure Context
        awk -v header="$subsection_header" -v entry="$entry" '
            BEGIN { in_failure = 0; added = 0 }
            /^## Failure Context/ {
                in_failure = 1
                print
                next
            }
            in_failure && /^## / && !added {
                # Hit next section - insert subsection before it
                print ""
                print header
                print ""
                print entry
                print ""
                added = 1
                in_failure = 0
                print
                next
            }
            { print }
            END {
                # If we reached EOF while in failure context, append at end
                if (in_failure && !added) {
                    print ""
                    print header
                    print ""
                    print entry
                }
            }
        ' "$AGENTS_FILE" > "$temp"
    fi

    # Atomic replace
    mv "$temp" "$AGENTS_FILE"
    return $?
}

# enforce_failure_cap - Enforce 100-failure limit per phase
# Args: phase_num - Phase number to enforce cap for
# Returns: 0 always
#
# Drops oldest failure if count >= 100 for this phase
enforce_failure_cap() {
    local phase_num="$1"

    if [[ ! -f "$AGENTS_FILE" ]]; then
        return 0  # No file, nothing to enforce
    fi

    local max_failures=100

    # Count failures for this phase
    local count
    count=$(grep -c "^- \[${phase_num}-" "$AGENTS_FILE" 2>/dev/null) || true
    count="${count%%$'\n'*}"; count="${count//[^0-9]/}"; count="${count:-0}"

    if [[ "$count" -lt "$max_failures" ]]; then
        return 0  # Under cap, nothing to do
    fi

    # Drop oldest failure (first match for this phase)
    local temp
    temp=$(mktemp)

    awk -v phase="${phase_num}" '
        BEGIN { dropped = 0 }
        /^- \[/ && $0 ~ "^- \\[" phase "-" && dropped == 0 {
            # Skip this line (drop oldest)
            # Also skip the next 3 lines (the multi-line entry continuation)
            dropped = 1
            getline; getline; getline
            next
        }
        { print }
    ' "$AGENTS_FILE" > "$temp"

    # Atomic replace
    mv "$temp" "$AGENTS_FILE"
    return 0
}

# clear_phase_failures - Remove all failure entries for a specific phase
# Args: phase_num - Phase number to clear
# Returns: 0 always
#
# Removes entire ### Phase N: subsection from ## Failure Context
# Called when phase boundary is crossed (phase completes successfully)
clear_phase_failures() {
    local phase_num="$1"

    # Remove leading zeros
    phase_num=$((10#$phase_num))

    if [[ ! -f "$AGENTS_FILE" ]]; then
        return 0  # No file, nothing to clear
    fi

    # Create temp file for atomic write
    local temp
    temp=$(mktemp)

    # Use awk to remove the ### Phase N: subsection from ## Failure Context
    awk -v phase="${phase_num}" '
        BEGIN {
            in_failure = 0
            in_phase = 0
        }
        # Track when we enter Failure Context section
        /^## Failure Context/ {
            in_failure = 1
            print
            next
        }
        # Track when we exit Failure Context section
        /^## / && in_failure {
            in_failure = 0
            in_phase = 0
        }
        # Found the phase subsection to remove
        $0 == "### Phase " phase ":" && in_failure {
            in_phase = 1
            next
        }
        # Exit the phase subsection when we hit another subsection or section
        ((/^### Phase/ && $0 != "### Phase " phase ":") || /^## /) && in_phase {
            in_phase = 0
        }
        # Print line if we are not inside the phase subsection
        !in_phase { print }
    ' "$AGENTS_FILE" > "$temp"

    # Atomic replace
    mv "$temp" "$AGENTS_FILE"
    return 0
}

# =============================================================================
# Size Management Functions
# =============================================================================

# prune_agents_if_needed - Enforce size limits on AGENTS.md
# Returns: 0 always
#
# Warning at MAX_AGENTS_LINES (100), hard cap at MAX_AGENTS_LINES_HARD (150)
# Per CONTEXT.md: system manages entirely, users don't manually curate
prune_agents_if_needed() {
    if [[ ! -f "$AGENTS_FILE" ]]; then
        return 0  # No file, nothing to prune
    fi

    local line_count
    line_count=$(wc -l < "$AGENTS_FILE")
    line_count=$(echo "$line_count" | tr -d ' ')

    # Under warning threshold - all good
    if [[ "$line_count" -le "$MAX_AGENTS_LINES" ]]; then
        return 0
    fi

    # Between warning and hard cap - just warn
    if [[ "$line_count" -le "$MAX_AGENTS_LINES_HARD" ]]; then
        echo -e "${LEARN_YELLOW}Warning: AGENTS.md has $line_count lines (limit: $MAX_AGENTS_LINES)${LEARN_RESET}" >&2
        return 0
    fi

    # Over hard cap - truncate oldest entries from each section
    echo -e "${LEARN_YELLOW}Warning: AGENTS.md has $line_count lines (hard cap: $MAX_AGENTS_LINES_HARD) - pruning oldest entries${LEARN_RESET}" >&2

    # Create temp file for atomic write
    local temp
    temp=$(mktemp)

    # Keep first 10 learnings per section (newest are first due to append order)
    # This is a simplified pruning - just keep header/intro and first 10 list items per section
    awk '
        BEGIN { section = ""; item_count = 0 }
        /^## / {
            section = $0
            item_count = 0
            print
            next
        }
        /^### / {
            section = $0
            item_count = 0
            print
            next
        }
        /^- / {
            item_count++
            if (item_count <= 10) {
                print
            }
            next
        }
        { print }
    ' "$AGENTS_FILE" > "$temp"

    # Atomic replace
    mv "$temp" "$AGENTS_FILE"

    return 0
}
