---
phase: 08-upfront-planning
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - bin/lib/state.sh
  - bin/lib/parse.sh
  - bin/lib/planning.sh
autonomous: true

must_haves:
  truths:
    - "Planning progress is tracked in STATE.md between sessions"
    - "All phases can be enumerated from ROADMAP.md"
    - "Session can resume from where it left off"
  artifacts:
    - path: "bin/lib/state.sh"
      provides: "Planning progress section management"
      contains: "update_planning_progress"
    - path: "bin/lib/parse.sh"
      provides: "Phase enumeration from roadmap"
      contains: "get_all_phases"
    - path: "bin/lib/planning.sh"
      provides: "Planning session management"
      contains: "init_planning_session"
  key_links:
    - from: "bin/lib/planning.sh"
      to: "bin/lib/state.sh"
      via: "source statement"
      pattern: "update_planning_progress"
    - from: "bin/lib/planning.sh"
      to: "bin/lib/parse.sh"
      via: "function call"
      pattern: "get_all_phases"
---

<objective>
Create infrastructure for multi-phase planning sessions

Purpose: Build the foundational library functions that track planning progress in STATE.md, enumerate phases from ROADMAP.md, and manage planning session state. This enables the plan-milestone-all command to generate all PLAN.md files sequentially with resumability.

Output: Extended state.sh with planning progress markers, extended parse.sh with phase enumeration, new planning.sh library with session management
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-upfront-planning/08-CONTEXT.md
@.planning/phases/08-upfront-planning/08-RESEARCH.md

# Files to modify
@bin/lib/state.sh
@bin/lib/parse.sh

# Reference patterns
@bin/lib/learnings.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add planning progress markers to STATE.md and update functions to state.sh</name>
  <files>bin/lib/state.sh</files>
  <action>
Add new functions to state.sh for planning progress tracking:

1. **init_planning_progress()** - Add planning progress section to STATE.md if not present:
   - Check if "<!-- PLANNING_PROGRESS_START -->" exists
   - If not, add the section after "## Next Action" section:
   ```markdown
   ## Planning Progress

   <!-- PLANNING_PROGRESS_START -->
   **Session:** none
   **Status:** not_started

   | Phase | Plans | Status | Generated |
   |-------|-------|--------|-----------|
   <!-- PLANNING_PROGRESS_END -->
   ```

2. **update_planning_progress()** - Update planning progress for a phase:
   - Args: phase_num, status (pending|in_progress|complete|failed), [plan_count]
   - Update the row for that phase in the progress table
   - Use sed/awk to find and update the matching row
   - If phase row doesn't exist, append it

3. **set_planning_session()** - Update session info:
   - Args: session_id (e.g., "planning-2026-01-19"), status (not_started|in_progress|completed|needs_refinement)
   - Update the **Session:** and **Status:** lines

4. **get_planning_status()** - Read current planning status:
   - Returns current session status (not_started|in_progress|completed|needs_refinement)
   - Parses the **Status:** line between planning markers

Follow existing state.sh patterns:
- Use atomic_write for file updates
- Use sed/awk for line-by-line updates
- Return exit codes (0 success, 1 failure)
- Error messages to stderr with color codes
  </action>
  <verify>
Run: `bash -n bin/lib/state.sh` - No syntax errors
Test: Source and call init_planning_progress, verify section added to STATE.md
Test: Call update_planning_progress "08" "in_progress" "2", verify row updated
  </verify>
  <done>
- init_planning_progress adds planning section to STATE.md
- update_planning_progress updates phase rows
- set_planning_session updates session info
- get_planning_status returns current status
- All functions follow existing state.sh patterns
  </done>
</task>

<task type="auto">
  <name>Task 2: Add phase enumeration functions to parse.sh</name>
  <files>bin/lib/parse.sh</files>
  <action>
Add new functions to parse.sh for phase enumeration:

1. **get_all_phases()** - Return list of all phases from ROADMAP.md:
   - Parse "### Phase N:" headers
   - Return space-separated list of phase numbers (e.g., "1 2 3 4 5 6 7 8 9 10")
   - Handle both integer (5) and decimal (2.1) phase numbers
   ```bash
   get_all_phases() {
       local roadmap="${ROADMAP_FILE:-.planning/ROADMAP.md}"
       grep -E '^### Phase [0-9]+(\.[0-9]+)?:' "$roadmap" | \
           sed 's/### Phase \([0-9.]*\):.*/\1/' | \
           sort -t. -k1,1n -k2,2n
   }
   ```

2. **phase_has_plans()** - Check if phase has PLAN.md files:
   - Args: phase_num
   - Returns: 0 if plans exist, 1 if not
   - Check for .planning/phases/{phase}-*/*-PLAN.md files
   ```bash
   phase_has_plans() {
       local phase_num="$1"
       local padded=$(printf "%02d" "$phase_num" 2>/dev/null || echo "$phase_num")
       ls .planning/phases/${padded}-*/*-PLAN.md 2>/dev/null | head -1 > /dev/null
   }
   ```

3. **get_phase_name()** - Get phase name from ROADMAP.md:
   - Args: phase_num
   - Returns: Phase name (e.g., "Safety Foundation" for phase 1)
   - Parse from "### Phase N: Name" header
   ```bash
   get_phase_name() {
       local phase_num="$1"
       grep -E "^### Phase ${phase_num}:" "$ROADMAP_FILE" | \
           sed 's/### Phase [0-9.]*: //'
   }
   ```

4. **get_unplanned_phases()** - Return list of phases without plans:
   - Filter get_all_phases() through phase_has_plans()
   - Return only phases that don't have PLAN.md files
   ```bash
   get_unplanned_phases() {
       local all_phases
       all_phases=$(get_all_phases)
       for phase in $all_phases; do
           if ! phase_has_plans "$phase"; then
               echo "$phase"
           fi
       done
   }
   ```

5. **count_phase_plans()** - Count PLAN.md files for a phase:
   - Args: phase_num
   - Returns: Number of PLAN.md files
   ```bash
   count_phase_plans() {
       local phase_num="$1"
       local padded=$(printf "%02d" "$phase_num" 2>/dev/null || echo "$phase_num")
       ls .planning/phases/${padded}-*/*-PLAN.md 2>/dev/null | wc -l | tr -d ' '
   }
   ```

Follow existing parse.sh patterns:
- Use ROADMAP_FILE variable
- Return exit codes appropriately
- Error messages to stderr
  </action>
  <verify>
Run: `bash -n bin/lib/parse.sh` - No syntax errors
Test: Source and call get_all_phases, verify returns "1 2 3 4 5 6 7 8 9 10"
Test: Call phase_has_plans "1", verify returns 0 (plans exist)
Test: Call phase_has_plans "8", verify returns 1 (no plans yet)
Test: Call get_unplanned_phases, verify returns "8 9 10"
  </verify>
  <done>
- get_all_phases returns all phase numbers from ROADMAP.md
- phase_has_plans correctly detects existing plans
- get_phase_name returns phase name
- get_unplanned_phases filters to unplanned phases
- count_phase_plans returns plan count
  </done>
</task>

<task type="auto">
  <name>Task 3: Create planning.sh library with session management</name>
  <files>bin/lib/planning.sh</files>
  <action>
Create new planning.sh library in bin/lib/ with planning session functions:

```bash
#!/bin/bash
# GSD Ralph - Planning Session Management
# Part of Phase 8: Upfront Planning
#
# Provides functions for multi-phase planning sessions.
# Functions: init_planning_session, plan_single_phase, get_planning_summary,
#            get_dependent_plans, warn_if_has_dependents
#
# Usage:
#   source bin/lib/planning.sh
#   init_planning_session
#   plan_single_phase 8

# Configuration
MAX_PLAN_RETRIES=3

# Color codes
PLAN_RED='\e[31m'
PLAN_GREEN='\e[32m'
PLAN_YELLOW='\e[33m'
PLAN_CYAN='\e[36m'
PLAN_RESET='\e[0m'
PLAN_BOLD='\e[1m'
```

**Functions to implement:**

1. **init_planning_session()** - Initialize a planning session:
   - Call init_planning_progress() from state.sh
   - Generate session ID: "planning-$(date '+%Y-%m-%d-%H%M')"
   - Call set_planning_session with session ID and "in_progress"
   - Return session ID

2. **show_planning_progress()** - Display current planning state:
   - Args: current_phase, total_phases, phase_name
   - Display banner with phase X/Y and name
   - Follows display.sh patterns for visual consistency
   ```bash
   show_planning_progress() {
       local current="$1"
       local total="$2"
       local name="$3"
       echo -e "${PLAN_CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${PLAN_RESET}"
       echo -e "${PLAN_CYAN} GSD ► PLANNING PHASE ${current}/${total}${PLAN_RESET}"
       echo -e "${PLAN_CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${PLAN_RESET}"
       echo ""
       echo -e "Phase: ${PLAN_BOLD}${name}${PLAN_RESET}"
       echo ""
   }
   ```

3. **get_dependent_plans()** - Find plans that depend on a given plan:
   - Args: plan_id (e.g., "08-01")
   - Search all PLAN.md frontmatter for depends_on containing this plan
   - Return list of dependent plan IDs
   ```bash
   get_dependent_plans() {
       local plan_id="$1"
       grep -l "depends_on:.*${plan_id}" .planning/phases/*/*-PLAN.md 2>/dev/null | \
           xargs -I{} basename {} 2>/dev/null | \
           sed 's/-PLAN\.md//'
   }
   ```

4. **warn_if_has_dependents()** - Warn if plan has dependents:
   - Args: plan_id
   - Call get_dependent_plans
   - If non-empty, print warning to stderr
   - Return 0 if no dependents, 1 if has dependents

5. **get_planning_summary()** - Generate summary table of all phases:
   - For each phase from get_all_phases:
     - Get phase name from get_phase_name
     - Get plan count from count_phase_plans
     - Determine status (complete/pending)
   - Return formatted markdown table
   ```bash
   get_planning_summary() {
       echo "| Phase | Name | Plans | Status |"
       echo "|-------|------|-------|--------|"
       for phase in $(get_all_phases); do
           local name
           name=$(get_phase_name "$phase")
           local count
           count=$(count_phase_plans "$phase")
           local status="pending"
           if [[ "$count" -gt 0 ]]; then
               status="complete"
           fi
           echo "| $phase | $name | $count | $status |"
       done
   }
   ```

6. **commit_phase_plans()** - Git commit plans for a phase:
   - Args: phase_num
   - Stage all PLAN.md files for that phase
   - Commit with standardized message
   ```bash
   commit_phase_plans() {
       local phase_num="$1"
       local padded=$(printf "%02d" "$phase_num" 2>/dev/null || echo "$phase_num")
       local phase_dir
       phase_dir=$(ls -d .planning/phases/${padded}-* 2>/dev/null | head -1)

       if [[ -d "$phase_dir" ]]; then
           git add "${phase_dir}"/*-PLAN.md
           git commit -m "docs(${padded}): create phase plans"
       fi
   }
   ```

Use conditional sourcing for dependencies (state.sh, parse.sh) since they may already be sourced by caller.
  </action>
  <verify>
Run: `bash -n bin/lib/planning.sh` - No syntax errors
Test: Source all libs and call init_planning_session, verify session created
Test: Call show_planning_progress "1" "10" "Safety Foundation", verify banner displays
Test: Call get_planning_summary, verify table shows all phases
  </verify>
  <done>
- planning.sh created with all session management functions
- init_planning_session creates session and tracks in STATE.md
- show_planning_progress displays visual progress
- get_dependent_plans and warn_if_has_dependents for refinement safety
- get_planning_summary generates status table
- commit_phase_plans handles git commits
  </done>
</task>

</tasks>

<verification>
End-to-end verification:
1. `bash -n bin/lib/state.sh` - No syntax errors
2. `bash -n bin/lib/parse.sh` - No syntax errors
3. `bash -n bin/lib/planning.sh` - No syntax errors
4. Source all libs: `source bin/lib/state.sh && source bin/lib/parse.sh && source bin/lib/planning.sh`
5. Call get_all_phases, verify returns all phase numbers
6. Call init_planning_session, verify STATE.md updated with planning section
7. Call get_planning_summary, verify shows all phases with status
</verification>

<success_criteria>
- state.sh extended with planning progress functions (init, update, set, get)
- parse.sh extended with phase enumeration functions (all, has, name, unplanned, count)
- planning.sh created with session management and display functions
- All functions return appropriate exit codes
- STATE.md gets Planning Progress section with markers
- No syntax errors in any modified files
</success_criteria>

<output>
After completion, create `.planning/phases/08-upfront-planning/08-01-SUMMARY.md`
</output>
