---
phase: 13-terminal-path-resolution
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - bin/lib/path-resolve.sh
  - bin/ralph.sh
autonomous: true

must_haves:
  truths:
    - "ralph.sh correctly resolves paths in Git Bash environment"
    - "ralph.sh correctly resolves paths in WSL environment"
    - "ralph.sh correctly resolves paths in Cygwin environment"
    - "Paths with spaces are handled correctly"
  artifacts:
    - path: "bin/lib/path-resolve.sh"
      provides: "Runtime bash environment detection and path conversion"
      exports: ["detect_bash_env", "resolve_win_path"]
      min_lines: 50
    - path: "bin/ralph.sh"
      provides: "Main script with path resolution sourced"
      contains: "source.*path-resolve.sh"
  key_links:
    - from: "bin/ralph.sh"
      to: "bin/lib/path-resolve.sh"
      via: "source"
      pattern: "source.*path-resolve\\.sh"
    - from: "resolve_win_path()"
      to: "cygpath"
      via: "command -v check"
      pattern: "command -v cygpath"
    - from: "resolve_win_path()"
      to: "wslpath"
      via: "command -v check"
      pattern: "command -v wslpath"
---

<objective>
Create runtime path resolution in ralph.sh that detects the bash environment (Git Bash, WSL, Cygwin) and converts Windows paths using native tools with a fallback chain.

Purpose: When wt.exe spawns a shell other than Git Bash (e.g., WSL, Cygwin), the `/c/Users/...` path format fails. Runtime detection ensures paths work regardless of which bash variant runs the script.

Output: bin/lib/path-resolve.sh library and integration into ralph.sh
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/13-terminal-path-resolution/13-RESEARCH.md

# The main script that will source the new library
@bin/ralph.sh

# Existing lib files for pattern reference
@bin/lib/budget.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create path-resolve.sh with environment detection</name>
  <files>bin/lib/path-resolve.sh</files>
  <action>
Create a new library file `bin/lib/path-resolve.sh` with runtime bash environment detection:

```bash
#!/bin/bash
# GSD Path Resolution - Runtime environment detection and path conversion
# Part of Phase 13: Terminal Path Resolution
#
# Detects which bash variant is running (Git Bash, WSL, Cygwin) and provides
# path conversion functions that work across all environments.
#
# Usage:
#   source path-resolve.sh
#   env=$(detect_bash_env)
#   unix_path=$(resolve_win_path "C:\Users\foo")

# =============================================================================
# Environment Detection
# =============================================================================

# detect_bash_env - Identify which bash variant is running
# Returns: "msys" (Git Bash/MSYS2), "wsl", "cygwin", or "unknown"
detect_bash_env() {
  # WSL sets WSL_DISTRO_NAME
  if [ -n "$WSL_DISTRO_NAME" ]; then
    echo "wsl"
    return 0
  fi

  # MSYS2/Git Bash sets MSYSTEM (MINGW64, MINGW32, MSYS, UCRT64, CLANG64)
  if [ -n "$MSYSTEM" ]; then
    echo "msys"
    return 0
  fi

  # Cygwin has distinct OSTYPE
  if [[ "$OSTYPE" == cygwin* ]]; then
    echo "cygwin"
    return 0
  fi

  # Native Linux/macOS or unknown Windows shell
  echo "unknown"
  return 0
}

# =============================================================================
# Path Resolution
# =============================================================================

# resolve_win_path - Convert Windows path to Unix format for current environment
# Args: $1 - Windows path (e.g., "C:\Users\foo" or "C:/Users/foo")
# Returns: Unix path appropriate for current bash variant
# Exit code: 0 on success, 1 if path cannot be resolved
resolve_win_path() {
  local win_path="$1"

  # Empty path - return empty
  if [ -z "$win_path" ]; then
    echo ""
    return 0
  fi

  # Already a Unix path (starts with /) - return as-is
  if [[ "$win_path" == /* ]]; then
    echo "$win_path"
    return 0
  fi

  # Try cygpath first (available in Git Bash, MSYS2, Cygwin)
  if command -v cygpath >/dev/null 2>&1; then
    local converted
    converted=$(cygpath -u "$win_path" 2>/dev/null)
    if [ $? -eq 0 ] && [ -n "$converted" ]; then
      echo "$converted"
      return 0
    fi
  fi

  # Try wslpath (available in WSL)
  if command -v wslpath >/dev/null 2>&1; then
    local converted
    converted=$(wslpath -u "$win_path" 2>/dev/null)
    if [ $? -eq 0 ] && [ -n "$converted" ]; then
      echo "$converted"
      return 0
    fi
  fi

  # Manual fallback: C:\foo or C:/foo -> detect mount prefix
  if [[ "$win_path" =~ ^([A-Za-z]):[/\\](.*)$ ]]; then
    local drive="${BASH_REMATCH[1],,}"  # lowercase
    local rest="${BASH_REMATCH[2]}"
    rest="${rest//\\//}"  # backslash to forward slash

    # Try each mount prefix format
    # WSL format: /mnt/c/...
    if [ -d "/mnt/$drive" ]; then
      echo "/mnt/$drive/$rest"
      return 0
    fi

    # Git Bash format: /c/...
    if [ -d "/$drive" ]; then
      echo "/$drive/$rest"
      return 0
    fi

    # Cygwin format: /cygdrive/c/...
    if [ -d "/cygdrive/$drive" ]; then
      echo "/cygdrive/$drive/$rest"
      return 0
    fi
  fi

  # Could not resolve - return original and signal failure
  echo "$win_path"
  return 1
}

# resolve_and_cd - Resolve path and change directory
# Args: $1 - Windows or Unix path
# Returns: 0 on success, 1 on failure
resolve_and_cd() {
  local target="$1"

  # Already a valid directory?
  if [ -d "$target" ]; then
    cd "$target" && return 0
  fi

  # Try to resolve the path
  local resolved
  resolved=$(resolve_win_path "$target")

  if [ -d "$resolved" ]; then
    cd "$resolved" && return 0
  fi

  # Failed to resolve
  echo "ERROR: Could not resolve path: $target" >&2
  echo "  Tried: $resolved" >&2
  echo "  Environment: $(detect_bash_env)" >&2
  return 1
}
```

This implements:
- PATH-01: detect_bash_env() for runtime environment detection
- PATH-02: resolve_win_path() uses cygpath/wslpath native tools
- PATH-03: Manual fallback chain when native tools unavailable
  </action>
  <verify>
- `bash -n bin/lib/path-resolve.sh` shows no syntax errors
- `ls bin/lib/path-resolve.sh` confirms file exists
- `grep "detect_bash_env" bin/lib/path-resolve.sh` shows function definition
- `grep "resolve_win_path" bin/lib/path-resolve.sh` shows function definition
  </verify>
  <done>path-resolve.sh library exists with detect_bash_env() and resolve_win_path() functions</done>
</task>

<task type="auto">
  <name>Task 2: Integrate path-resolve.sh into ralph.sh</name>
  <files>bin/ralph.sh</files>
  <action>
Add the path-resolve.sh source to ralph.sh after the existing lib sources (after line 31 which sources learnings.sh):

Find the block:
```bash
source "${SCRIPT_DIR}/lib/learnings.sh"
```

Add after it:
```bash
source "${SCRIPT_DIR}/lib/path-resolve.sh"
```

The path resolution functions are now available throughout ralph.sh. The current ralph.sh doesn't explicitly handle Windows paths passed as arguments (it relies on the terminal launcher to set up the environment), but having the library available enables future use and ensures the functions are tested when ralph.sh loads.

Note: ralph.sh currently uses SCRIPT_DIR which is already computed correctly using `dirname "${BASH_SOURCE[0]}"`. The path-resolve.sh library will be used by any code that needs to handle Windows paths at runtime.
  </action>
  <verify>
- `grep "path-resolve.sh" bin/ralph.sh` shows the source line
- `bash -n bin/ralph.sh` shows no syntax errors (validates the sourced file too)
  </verify>
  <done>ralph.sh sources path-resolve.sh library</done>
</task>

<task type="auto">
  <name>Task 3: Add path resolution diagnostic output for debugging</name>
  <files>bin/lib/path-resolve.sh</files>
  <action>
Add a diagnostic function to path-resolve.sh that can be called for troubleshooting. Add at the end of the file:

```bash
# =============================================================================
# Diagnostics
# =============================================================================

# path_resolve_diag - Print diagnostic information about path resolution
# Useful for troubleshooting when paths don't resolve correctly
path_resolve_diag() {
  echo "=== Path Resolution Diagnostics ==="
  echo ""
  echo "Environment:"
  echo "  OSTYPE:          ${OSTYPE:-not set}"
  echo "  MSYSTEM:         ${MSYSTEM:-not set}"
  echo "  WSL_DISTRO_NAME: ${WSL_DISTRO_NAME:-not set}"
  echo "  Detected env:    $(detect_bash_env)"
  echo ""
  echo "Available tools:"
  echo "  cygpath:         $(command -v cygpath 2>/dev/null || echo 'not found')"
  echo "  wslpath:         $(command -v wslpath 2>/dev/null || echo 'not found')"
  echo ""
  echo "Mount points:"
  echo "  /mnt/c:          $([ -d /mnt/c ] && echo 'exists' || echo 'not found')"
  echo "  /c:              $([ -d /c ] && echo 'exists' || echo 'not found')"
  echo "  /cygdrive/c:     $([ -d /cygdrive/c ] && echo 'exists' || echo 'not found')"
  echo ""

  # Test path resolution if argument provided
  if [ -n "$1" ]; then
    echo "Test path: $1"
    local resolved
    resolved=$(resolve_win_path "$1")
    local exit_code=$?
    echo "  Resolved to: $resolved"
    echo "  Exit code:   $exit_code"
    echo "  Is directory: $([ -d "$resolved" ] && echo 'yes' || echo 'no')"
  fi

  echo "==================================="
}

# CLI support - run directly for testing
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  path_resolve_diag "$@"
fi
```

This diagnostic function helps users troubleshoot path resolution issues by showing:
- Which bash environment was detected
- Which native tools are available
- Which mount points exist
- Test conversion of a specific path

Can be run directly: `bash bin/lib/path-resolve.sh "C:\Users\foo"`
  </action>
  <verify>
- `bash bin/lib/path-resolve.sh` runs without error and shows diagnostic output
- `grep "path_resolve_diag" bin/lib/path-resolve.sh` shows function definition
  </verify>
  <done>path-resolve.sh has diagnostic function for troubleshooting</done>
</task>

</tasks>

<verification>
1. `bash -n bin/lib/path-resolve.sh` - no syntax errors
2. `bash -n bin/ralph.sh` - no syntax errors (validates sourced files)
3. `bash bin/lib/path-resolve.sh` - runs diagnostic output
4. `grep "detect_bash_env\|resolve_win_path\|resolve_and_cd" bin/lib/path-resolve.sh` - all functions present
5. `grep "path-resolve.sh" bin/ralph.sh` - library is sourced
</verification>

<success_criteria>
- [ ] bin/lib/path-resolve.sh exists with 50+ lines
- [ ] detect_bash_env() function detects msys, wsl, cygwin, unknown
- [ ] resolve_win_path() tries cygpath first, then wslpath, then manual fallback
- [ ] Manual fallback checks /mnt/$drive, /$drive, /cygdrive/$drive
- [ ] resolve_and_cd() convenience function exists
- [ ] path_resolve_diag() diagnostic function exists
- [ ] ralph.sh sources path-resolve.sh
- [ ] No syntax errors in either file
</success_criteria>

<output>
After completion, create `.planning/phases/13-terminal-path-resolution/13-02-SUMMARY.md`
</output>
