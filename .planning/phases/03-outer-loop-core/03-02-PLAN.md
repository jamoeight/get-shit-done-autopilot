---
phase: 03-outer-loop-core
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - bin/lib/invoke.sh
  - bin/ralph.sh
autonomous: true

must_haves:
  truths:
    - "invoke_claude spawns fresh Claude instance with full GSD context"
    - "JSON output from Claude is captured and parsed"
    - "Spinner displays while Claude is working"
    - "Failure pauses with Retry/Skip/Abort options"
    - "Success updates STATE.md and logs result"
  artifacts:
    - path: "bin/lib/invoke.sh"
      provides: "Claude CLI invocation wrapper"
      min_lines: 80
    - path: "bin/ralph.sh"
      provides: "Complete outer loop with Claude invocation"
      min_lines: 150
  key_links:
    - from: "bin/ralph.sh"
      to: "bin/lib/invoke.sh"
      via: "source statement"
      pattern: "source.*invoke\\.sh"
    - from: "bin/lib/invoke.sh"
      to: "claude"
      via: "CLI invocation"
      pattern: "claude -p"
---

<objective>
Add Claude CLI invocation with JSON parsing, spinner display, and failure handling to complete the functional outer loop.

Purpose: Transform the skeleton loop into a working automation that actually spawns Claude to execute plans. This is the core automation - making Claude do the work while ralph.sh orchestrates.

Output: Fully functional ralph.sh that spawns Claude, parses results, handles failures with user options, and updates state on success.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-outer-loop-core/03-CONTEXT.md
@.planning/phases/03-outer-loop-core/03-RESEARCH.md
@.planning/phases/03-outer-loop-core/03-01-SUMMARY.md
@bin/ralph.sh
@bin/lib/parse.sh
@bin/lib/failfast.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create invoke.sh with Claude CLI wrapper</name>
  <files>bin/lib/invoke.sh</files>
  <action>
Create `bin/lib/invoke.sh` with these functions:

1. **invoke_claude()** - Main invocation function
   Args: plan_id (e.g., "03-01")

   Implementation:
   - Build the prompt string that tells Claude what to execute:
     ```
     Execute plan ${plan_id}.

     Read the plan file and follow the execute-plan workflow.
     Create atomic commits for each task.
     Create SUMMARY.md when complete.
     Update STATE.md with position and decisions.
     ```
   - Create temp file for output: `output_file=$(mktemp)`
   - Invoke Claude with:
     ```bash
     claude -p "$prompt" \
         --output-format json \
         --allowedTools "Bash,Read,Write,Edit,Glob,Grep,WebFetch" \
         > "$output_file" 2>&1
     ```
   - Capture exit code
   - On success: cat output_file to stdout, return 0
   - On failure: echo error to stderr, cat output_file to stderr, return exit code
   - Always rm -f temp file

2. **parse_claude_result()** - Extract summary from JSON output
   Args: json_output (string)

   Implementation:
   - Check if jq is available: `command -v jq &>/dev/null`
   - If jq available: Extract result field with `jq -r '.result // "No result"'`
   - If no jq: Use grep fallback to extract result (simplified)
   - Return extracted summary string

3. **check_iteration_duration()** - Alert if iteration took too long
   Args: start_time (epoch seconds)

   Implementation:
   - Calculate elapsed = now - start_time
   - If elapsed > 1800 (30 min), return 1 (alert needed)
   - Else return 0

Follow existing lib file patterns:
- Use same color code style (INVOKE_RED, etc.)
- Include header comment with function list
- Return exit codes, don't exit directly
- Use the patterns from 03-RESEARCH.md

NOTE: Do NOT include --append-system-prompt-file flag - Claude Code already has GSD context from the user's .claude installation. The prompt itself provides task-specific instructions.
  </action>
  <verify>
Run: `bash -n bin/lib/invoke.sh` (syntax check passes)
Run: Source the file and verify functions are defined: `type invoke_claude`
  </verify>
  <done>
invoke.sh exists with invoke_claude, parse_claude_result, and check_iteration_duration functions. Syntax check passes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add spinner and failure handling to ralph.sh</name>
  <files>bin/ralph.sh</files>
  <action>
Add to ralph.sh:

1. **Source invoke.sh:**
   Add `source "${SCRIPT_DIR}/lib/invoke.sh"` with other sources

2. **Add spinner functions** (before main loop):
   ```bash
   SPINNER_PID=""

   start_spinner() {
       local message="$1"
       local spin_chars='|/-\'

       {
           local i=0
           while true; do
               local char="${spin_chars:$i:1}"
               printf "\r${CYAN}%s %s${RESET}" "$message" "$char"
               i=$(( (i + 1) % 4 ))
               sleep 0.25
           done
       } &

       SPINNER_PID=$!
   }

   stop_spinner() {
       if [[ -n "$SPINNER_PID" ]]; then
           kill "$SPINNER_PID" 2>/dev/null
           wait "$SPINNER_PID" 2>/dev/null || true
           SPINNER_PID=""
           printf "\r\033[2K"
       fi
   }

   trap stop_spinner EXIT
   ```

3. **Add failure handling function:**
   ```bash
   handle_iteration_failure() {
       local task="$1"
       local error="$2"

       echo ""
       echo -e "${RED}${BOLD}FAILURE: Task '$task' failed${RESET}"
       echo -e "${RED}$error${RESET}"
       echo ""

       echo -e "Options:"
       echo -e "  ${YELLOW}r${RESET} - Retry this task"
       echo -e "  ${YELLOW}s${RESET} - Skip and continue to next"
       echo -e "  ${YELLOW}a${RESET} - Abort ralph loop"
       echo ""

       while true; do
           read -p "Choice [r/s/a]: " choice
           case "$choice" in
               r|R) return 0 ;;  # Retry
               s|S) return 1 ;;  # Skip
               a|A) return 2 ;;  # Abort
               *) echo "Invalid choice. Enter r, s, or a." ;;
           esac
       done
   }
   ```

4. **Update the main loop** - Replace the TODO section with real execution:
   - Remove the `break` statement that was placeholder
   - Record iteration_start_time
   - Start spinner with "[N/MAX] Running PLAN_ID..."
   - Call invoke_claude
   - Stop spinner
   - Check iteration duration and log alert if needed
   - On success: log SUCCESS, update iteration history, continue loop
   - On failure: call handle_iteration_failure and act on return value

See 03-RESEARCH.md for the complete loop structure pattern.
  </action>
  <verify>
Run: `bash -n bin/ralph.sh` (syntax check passes)
Run: `./bin/ralph.sh` - should show spinner briefly then stop (if Claude not configured, will fail and show failure menu)
  </verify>
  <done>
ralph.sh has spinner functions, failure handling with menu, and complete main loop that invokes Claude. Syntax check passes.
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire success path with state updates</name>
  <files>bin/ralph.sh</files>
  <action>
Complete the success path in ralph.sh main loop:

1. **After successful invoke_claude:**
   - Parse result summary: `summary=$(parse_claude_result "$output")`
   - Log to ralph.log with SUCCESS status and summary
   - Call add_iteration_entry from state.sh: `add_iteration_entry "$iteration" "SUCCESS" "$next_task: $summary"`
   - Update progress: Get completed/total from ROADMAP.md and call update_progress

2. **Add completion detection:**
   - After state update, re-parse next task
   - If next task is COMPLETE, show success message and break

3. **Add crash detection:**
   - If invoke_claude fails with signal (exit code > 128), treat as crash
   - Log CRASH to ralph.log
   - Show error: "Claude process crashed (signal X). Aborting."
   - Exit immediately (no retry menu for crashes per CONTEXT.md decisions)

4. **Update log format** to include duration:
   - Calculate duration = now - iteration_start_time
   - Add "Duration: Xs" line to log entry

5. **Final cleanup:**
   - At script end, show final statistics: iterations completed, total time, final status
   - If loop completed normally: "Ralph complete: N iterations, Xh Ym total time"
  </action>
  <verify>
Run: `bash -n bin/ralph.sh` (syntax check passes)
Manual test: If Claude CLI is available, `./bin/ralph.sh` should execute one plan and show results
  </verify>
  <done>
ralph.sh has complete success path: parses results, updates state, logs with duration, detects completion, handles crashes, shows final statistics.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `bash -n bin/ralph.sh` passes
2. `bash -n bin/lib/invoke.sh` passes
3. ralph.sh sources invoke.sh without errors
4. Spinner starts and stops cleanly (test with Ctrl+C to verify cleanup)
5. Failure menu shows r/s/a options and responds correctly
6. Success path updates STATE.md iteration history
7. ralph.log entries include duration
8. Crash detection works (exit code > 128 triggers immediate abort)
</verification>

<success_criteria>
- invoke.sh exists with invoke_claude, parse_claude_result, check_iteration_duration
- ralph.sh has working spinner with proper cleanup trap
- Failure handling shows Retry/Skip/Abort menu
- Success path updates STATE.md and ROADMAP.md progress
- ralph.log includes all iteration details with duration
- Crash detection triggers immediate abort
- Loop continues until completion or limit reached
- Ready for Plan 03 cross-platform verification
</success_criteria>

<output>
After completion, create `.planning/phases/03-outer-loop-core/03-02-SUMMARY.md`
</output>
