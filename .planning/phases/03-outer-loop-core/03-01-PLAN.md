---
phase: 03-outer-loop-core
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - bin/ralph.sh
  - bin/lib/parse.sh
autonomous: true

must_haves:
  truths:
    - "ralph.sh can be invoked from command line"
    - "Script loads configuration and shows startup summary"
    - "Loop iterates until completion or budget cap reached"
    - "Each iteration reads next task from STATE.md"
    - "Iteration outcome updates STATE.md history and position"
  artifacts:
    - path: "bin/ralph.sh"
      provides: "Main outer loop entry point"
      min_lines: 80
    - path: "bin/lib/parse.sh"
      provides: "STATE.md and ROADMAP.md parsing utilities"
      min_lines: 40
      exports: ["parse_next_task", "find_plan_file", "get_plan_name"]
  key_links:
    - from: "bin/ralph.sh"
      to: "bin/lib/state.sh"
      via: "source statement"
      pattern: "source.*lib/state\\.sh"
    - from: "bin/ralph.sh"
      to: "bin/lib/parse.sh"
      via: "source statement"
      pattern: "source.*lib/parse\\.sh"
    - from: "bin/lib/parse.sh"
      to: ".planning/STATE.md"
      via: "grep for Description line"
      pattern: "grep.*Description.*STATE"
---

<objective>
Create ralph.sh script skeleton with iteration control and STATE.md parsing.

Purpose: This is the core outer loop that drives autonomous execution - the foundation of lazy mode.
Output: Executable ralph.sh that iterates, reads STATE.md for next task, and updates state after each iteration.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-outer-loop-core/03-CONTEXT.md
@.planning/phases/03-outer-loop-core/03-RESEARCH.md

# Existing lib infrastructure to compose
@bin/lib/state.sh
@bin/lib/budget.sh
@bin/lib/display.sh
@bin/lib/failfast.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create parse.sh library for STATE.md/ROADMAP.md parsing</name>
  <files>bin/lib/parse.sh</files>
  <action>
Create bin/lib/parse.sh with functions for extracting task information:

**parse_next_task()**
- Read STATE.md "Description:" line in Next Action section
- Extract plan ID (e.g., "03-01") using grep -oE pattern
- Return "COMPLETE" if no next task found
- Return plan ID on success

**find_plan_file()**
- Args: plan_id (e.g., "03-01")
- Extract phase number from plan_id
- Find the phase directory matching that number
- Return full path to PLAN.md file
- Handle both zero-padded (03) and unpadded (3) folder names

**get_plan_name()**
- Args: plan_id (e.g., "03-01")
- Find the plan file and extract objective
- Parse first line after <objective> tag
- Return short description (first ~50 chars)

Follow existing lib/ patterns:
- Use STATE_FILE variable (default .planning/STATE.md)
- Add error messages with color codes
- Return exit codes (0=success, 1=failure)
- Include file header comment block matching other lib files
  </action>
  <verify>
Source the file and test:
```bash
source bin/lib/parse.sh
parse_next_task  # Should return "03-01" or similar
find_plan_file "03-01"  # Should return path
```
  </verify>
  <done>parse.sh exports parse_next_task, find_plan_file, get_plan_name functions that correctly parse STATE.md</done>
</task>

<task type="auto">
  <name>Task 2: Create ralph.sh main script with iteration loop</name>
  <files>bin/ralph.sh</files>
  <action>
Create bin/ralph.sh as the main outer loop entry point:

**Shebang and setup:**
```bash
#!/bin/bash
set -euo pipefail
```

**Script directory and sourcing:**
- Determine SCRIPT_DIR using BASH_SOURCE pattern
- Source all lib files: budget.sh, state.sh, display.sh, failfast.sh, parse.sh

**Startup sequence:**
1. Call load_config (from budget.sh)
2. Set START_TIME=$(date +%s)
3. Show startup summary: config values, current position from STATE.md, next task
4. Call mark_checkpoint (from failfast.sh)

**--start-from flag parsing:**
- Check for --start-from argument
- If provided, validate format (NN-MM)
- Override starting task

**Main loop:**
```bash
iteration=0
while true; do
    iteration=$((iteration + 1))

    # Check budget limits
    if ! check_limits "$iteration"; then
        handle_limit_reached
        exit 1
    fi

    # Get next task
    next_task=$(parse_next_task)
    if [[ "$next_task" == "COMPLETE" || -z "$next_task" ]]; then
        show_status "All tasks complete!" "success"
        break
    fi

    # Show iteration start
    show_status "[$iteration/$MAX_ITERATIONS] Starting $next_task..." "info"

    # PLACEHOLDER: Claude invocation will be added in 03-02
    # For now, just log and exit for testing
    echo "TODO: invoke_claude $next_task"
    break  # Exit after first iteration for now
done
```

**Post-loop cleanup:**
- Show completion summary
- Log to .planning/ralph.log

**Make executable:** chmod +x bin/ralph.sh
  </action>
  <verify>
```bash
chmod +x bin/ralph.sh
./bin/ralph.sh  # Should show startup summary, then TODO message and exit
./bin/ralph.sh --start-from 03-02  # Should parse flag correctly
```
  </verify>
  <done>ralph.sh runs, loads config, shows startup summary, parses next task, and has main loop structure ready for Claude invocation</done>
</task>

<task type="auto">
  <name>Task 3: Add iteration logging and state update integration</name>
  <files>bin/ralph.sh</files>
  <action>
Extend ralph.sh with iteration tracking and state updates:

**Log file setup:**
```bash
LOG_FILE="${LOG_FILE:-.planning/ralph.log}"
```

**log_iteration function:**
- Args: iteration, status, task, summary, duration
- Append formatted entry to LOG_FILE
- Include timestamp, iteration number, task ID, status, duration, summary

**Update main loop to track timing:**
- Record iteration_start=$(date +%s) before Claude invocation placeholder
- Calculate duration after completion
- Call log_iteration with results

**Integrate state.sh functions in success path:**
- add_iteration_entry "$iteration" "SUCCESS" "$next_task: $summary"
- Determine next task and call update_next_action
- Call update_progress with counts from get_plans_completed/get_total_plans

**Integrate state.sh functions in failure path:**
- add_iteration_entry "$iteration" "FAILURE" "$next_task: $error"
- Do NOT update next_action (stay on same task for retry)

**show_startup_summary function:**
- Display MAX_ITERATIONS and TIMEOUT_HOURS
- Parse and show current phase/plan from STATE.md
- Show next task name
- Use colors from display.sh
  </action>
  <verify>
```bash
# Manually test state updates work
source bin/lib/state.sh
add_iteration_entry 1 "SUCCESS" "03-01: Test entry"
cat .planning/STATE.md | grep -A5 "HISTORY_START"  # Should show entry
```
  </verify>
  <done>ralph.sh logs iterations to ralph.log and updates STATE.md history/progress after each iteration</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `./bin/ralph.sh` runs without errors and shows startup summary
2. `source bin/lib/parse.sh && parse_next_task` returns valid plan ID
3. ralph.log file is created with iteration entries
4. STATE.md iteration history updates correctly
5. Script handles --start-from flag
</verification>

<success_criteria>
- ralph.sh is executable and runs the main loop
- parse.sh correctly extracts next task from STATE.md
- Iteration logging works (ralph.log populated)
- State updates integrate with existing state.sh functions
- Script is ready for Claude invocation to be added in 03-02
</success_criteria>

<output>
After completion, create `.planning/phases/03-outer-loop-core/03-01-SUMMARY.md`
</output>
